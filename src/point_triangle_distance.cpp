#include "point_triangle_distance.h"
#include "igl/per_face_normals.h"
#include <cassert>
#include <map>
#include <Eigen/Dense>
#include <cmath>
#include <algorithm>


void point_triangle_distance(
  const Eigen::RowVector3d & x,
  const Eigen::RowVector3d & a,
  const Eigen::RowVector3d & b,
  const Eigen::RowVector3d & c,
  double & d,
  Eigen::RowVector3d & p)
{
  using RVec = Eigen::RowVector3d;
  using Mat = Eigen::MatrixXd;
  RVec ab = b - a;
  RVec ac = c - a;
  RVec ax = x - a;
  RVec bc = c - b;
  RVec xb = b - x;

  // calculate the normal of the plane generated by the points
  RVec normal = ab.cross(ac);
  normal /= normal.norm();

  RVec x_plane_projection = x - (x-a).dot(normal) * normal;

  // Calculate barycenter cordinates of x w.r.t the plane <normal>
  Mat xbc_triangle(3,3);
  Mat axc_triangle(3,3);
  Mat abx_triangle(3,3);
  Mat abc_triangle(3,3);
  xbc_triangle << x_plane_projection, b, c;
  axc_triangle << a, x_plane_projection, c;
  abx_triangle << a, b, x_plane_projection;
  abc_triangle << a, b, c;
  double lambda_0 = xbc_triangle.determinant() / abc_triangle.determinant();
  double lambda_1 = axc_triangle.determinant() / abc_triangle.determinant();
  double lambda_2 = abx_triangle.determinant() / abc_triangle.determinant();
  // std::cassert(1 - (lambda_0 + lambda_1 + lambda_2) > 1e-10);

  // if all barycenter coordinates are positive <x_plane_projection> lies in the
  // triangle
  // if two are positive, <x_plane_projection> is closest to the line segment
  // between the corresponding nodes
  // otherwise <x_plane_projection> is closest to the node with the positive
  // barycenter coordinate
  using Map = std::multimap<double, RVec>;
  Map barycenter_coord;
  barycenter_coord.insert(std::pair<double, RVec> (lambda_0,  a));
  barycenter_coord.insert(std::pair<double, RVec> (lambda_1,  b));
  barycenter_coord.insert(std::pair<double, RVec> (lambda_2,  c));

  RVec closest_pt = RVec::Zero();
  double sum_weights = 0;
  Map::iterator first_non_neg = barycenter_coord.lower_bound(0);
  for (Map::iterator it=first_non_neg; it != barycenter_coord.end(); it++)
  {
    closest_pt += it->first * it->second;
    sum_weights += it->first;
  }
  p = closest_pt / sum_weights;
  d = (x-p).norm();
}
